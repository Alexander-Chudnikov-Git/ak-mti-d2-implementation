# ak-mti-d2-implementation

## Обзор
`ak-mti-d2-implementation` — это проект, направленный на реализацию протокола MTI (Message Transmission Infrastructure) с поддержкой эллиптических кривых. Цель проекта — создать надежное, безопасное и эффективное решение для обмена сообщениями, использующее протоколы MTI/D2 для передачи данных.

## Как использовать

Этот раздел скоро появится!

## Технологии используемые в проекте

### Протокол MTI
MTI (Message Transmission Infrastructure) — это протокол, используемый для безопасной передачи сообщений между системами. Он основан на криптографии с использованием эллиптических кривых, что обеспечивает надежное шифрование и эффективные механизмы обмена ключами. Протокол MTI/D2 предназначен для аутентифицированного обмена общим ключом между двумя сторонами взаимодействия и реализуется в группе точек эллиптической кривой, параметры которой соответствуют требованиям ГОСТ Р 34.102-1.

### D2
D2 — это дополнительное расширение, которое работает вместе с протоколом MTI. Протокол MTI/D2 состоит максимум из шести обменов сообщениями, выбранных из множества, указанного в таблице ниже.

### Принцип работы

Точное количество сообщений, передаваемых в ходе выполнения протокола, зависит от предварительного распределения сертификатов открытых ключей аутентификации субъектов взаимодействия до начала его выполнения. Перед началом выполнения протокола и обмена сообщениями субъектам взаимодействия известны следующие подтвержденные значения.

Протокол MTI/D2 можно разделить на два этапа. 

## Этап 1: Идентификация субъектов

### Сообщение ICA (A → B):
1. A генерирует случайный скаляр `ξ_A` в поле `F_p`.
2. Вычисляет `E_A = [ξ_A]P` (где `P` — базовая точка кривой).
3. Решает, будет ли он запрашивать сертификат B (логический флаг `reqA = true/false`).
4. Отправляет B сообщение ICA: `{reqA, N_A, E_A}`

   - `N_A` — идентификатор или сериализованный номер сертификата A.
   - Если `reqA = true`, значит A запрашивает сертификат B впоследствии.

### Обработка ICA на стороне B:
1. При получении сообщения ICA, B проверяет `reqA`.
2. Если A запрашивает сертификат B, B запоминает, что нужно будет отправить полный сертификат.
3. B пытается найти и проверить сертификат A (если он не известен заранее). Для этого может использовать `N_A`:
   - Либо найти `Cert_A` локально.
   - Либо, если сертификат не найден, запросить его у A на следующем шаге.

### Ответ 3CA (B → A) – Запрос сертификата A (опционально):
1. Если B не знает сертификат A или хочет его проверить, B отправляет сообщение 3CA: `{E_B (или N_B), возможно N_Ψ}`
   
   - `E_B` или `N_B` может быть либо сам сертификат B, либо его номер.
   
2. Этот шаг может отличаться в зависимости от реализации протокола:
   - Либо B сразу отправляет свою точку `E_B`.
   - Либо сначала запрашивает у A сертификат.

### Ответ CCA (A → B) – Сертификат A (при необходимости):
7. Если B запросил сертификат A, A отправляет {Cert_A} в сообщении CCA.
8. B выполняет verifyCert(Cert_A, Cert_U1). Если проверка неуспешна – протокол завершается с ошибкой.

### Переход к вычислениям B:
9. Теперь B имеет E_A и, если нужно, Cert_A с открытым ключом Q_A. B проверяет, что E_A лежит на кривой, и координата x(E_A) отличается от координаты x(Q_A). Это внутренние криптографические проверки.
10. B генерирует свой случайный скаляр ξ_B и вычисляет E_B = [ξ_B]P.
11. Формирует ключевую точку Q_BA = [ξ_B + d_B]C_A, где C_A = Q_A + E_A (операции эллиптического суммирования). Это подготовка к дальнейшей аутентификации.
12. B использует Q_BA для выработки промежуточных ключей. Генерирует ξ_BA, дополнительные параметры X_B, v_BA и R_B = enc(X_B, ξ_BA, v_BA) (шифрование при необходимости).
- X_B || v_BA || ... – данные, которые будут использоваться для аутентификации.

### Сообщение ИСБ/ИСБС (B → A):
13. B отправляет А {R_B, E_B, N_B} в сообщении ИСБ. Если reqA = true, то вместо N_B отправляется полный Cert_B (тогда сообщение называется ИСБС).
14. A, получив это, при необходимости обрабатывает Cert_B, если был запрошен. Проверяет verifyCert(Cert_B, Cert_U1).

На этом этапе A и B знают идентификаторы и открытые ключи друг друга (либо имеют их сертификаты), а также обменялись случайными точками E_A и E_B.

## Этап 2: Взаимная аутентификация и выработка общего ключа

Оба участника имеют открытые ключи друг друга (Q_A, Q_B) и случайные точки (E_A, E_B), а также знают идентификаторы ID_A, ID_B.

## Действия на стороне A (после получения ИСБ/ИСБС):
15. Если A получил только номер сертификата B (N_B), но не сам сертификат, A выполняет Cert_B = find(N_B) из локального хранилища.
16. Выполняет verifyCert(Cert_B, Cert_U1). Если сертификат невалиден – останов.
17. Из Cert_B извлекает открытый ключ B: Q_B.
18. Проверяет E_B (лежит ли точка на кривой, координаты, отличия и т.д.).
19. Рассчитывает C_B = Q_B + E_B. Убеждается, что C_B не является особой точкой.
20. Рассчитывает общий ключ: Q_AB = [ξ_A + d_A]C_B. Это главная операция, которая объединяет секреты A и B.
21. Получает ξ_AB – дополнительный случайный скаляр, генерирует X_A и v_AB, шифрует данные: R_A = enc(X_A, ξ_AB, v_AB).
22. Формирует проверочные значения: P_A = dec(X_B, R_B, v_BA) (раскрывая данные, посланные B), T_A = mac(Y_A, ID_A || ξ_AB || P_A) или какие-то иные производные значения, в зависимости от протокола.
23. Отправляет B сообщение АС {R_A, T_A}, позволяя B проверить подлинность A.

### Действия на стороне B (после получения АС):
24. B, получив {R_A, T_A}, проверяет подлинность:
- Аналогично, у B есть X_B, Y_B, Q_BA.
- B расшифровывает R_A, вычисляет P_B = dec(X_A, R_A, v_AB), проверяет T_A с помощью MAC. Если T_A корректен, значит A успешно аутентифицирован.
25. B отвечает сообщением AS {T_B}, где T_B = mac(Y_B, ID_B || ξ_BA || P_B), подтверждая аутентификацию B перед A.

### Действия на стороне A (после получения АS):
26. A проверяет T_B. Если проверка прошла успешно, A убеждается в подлинности B.

## Завершение
27. Оба участника вычисляют конечный общий ключ K_AB = kdf(Q_AB, H_A2) (где H_A2 – некая дополнительная информация, вроде конкатенации ID, случайных элементов и др.).
28. Теперь K_AB может использоваться для дальнейшего зашифрованного общения.


## Библиотеки

В проекте используется следующие библиотеки:

### Стандартная библиотека C++
- <vector>, <string>, <array> для хранения бинарных данных.
- <random> для генерации случайных чисел.
- <chrono> для меток времени.
- <optional> для возвращаемых значений.

### Библиотека MTI/D2

- **libakrypt**: Криптографическая библиотека, которая предоставляет необходимые криптографические функции, включая операции с эллиптическими кривыми, используемые в протоколе MTI/D2 для обеспечения безопасной связи.

## Структура проекта (Пример раздела)
- crypto_utils.h/.cpp – вспомогательные функции для криптографии.
- cert_store.h/.cpp – функции для хранения/поиска сертификатов и их верификации.
- message_formats.h/.cpp – структуры для сериализации/десериализации сообщений протокола.
- protocol_mti_d2.h/.cpp – основная логика протокола.
- network.h/.cpp – использование библиотеки для передачи сообщений.

## Результаты

Этот раздел скоро появится.

## Участники

Этот проект разрабатывается:

- **[Александр Чудников]** — Руководитель проекта и разработчик
- **[Егор Хохлов]** — Помощник разработчика
- **[Тимур Абдуллабеков]** — Специалист по криптографии
